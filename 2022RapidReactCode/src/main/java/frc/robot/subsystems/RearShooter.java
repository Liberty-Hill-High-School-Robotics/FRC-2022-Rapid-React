// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

// ***********************************************************************************************
// * 2/28/2022 Remove all AUTO-GENERATE COMMENTS
// ***********************************************************************************************

package frc.robot.subsystems;

import frc.robot.Constants;
import frc.robot.RobotContainer;
import frc.robot.Constants.ShootingConstants.ShootingPosition;
import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.ctre.phoenix.led.CANdle.VBatOutputMode;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.revrobotics.CANSparkMax;
import com.revrobotics.ControlType;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.SparkMaxPIDController;
import com.revrobotics.CANSparkMax.IdleMode;

/**
 *
 */
public class RearShooter extends SubsystemBase {
    /* -----------------------------------------------------------------------------------------------
     * Variables for DashBoard PID -- TESTING ONLY
     * -----------------------------------------------------------------------------------------------*/
    private final double MAX_SHOOTER_VELOCITY = 5700;
    private double CURRENT_SHOOTER_VELOCITY = 0.0;

    /* -----------------------------------------------------------------------------------------------
     * Variables for PERCENT OUTPUT --  TESTING ONLY
     * -----------------------------------------------------------------------------------------------*/
    private final double REAR_POWER = 1;

    /* -----------------------------------------------------------------------------------------------
     * Variables for CANSparkMAX
     * -----------------------------------------------------------------------------------------------*/
    private CANSparkMax canSparkMAXRearShooter;

    /* -----------------------------------------------------------------------------------------------
     * Variables for Automatic PID Closed Loop Control
     * -----------------------------------------------------------------------------------------------*/
    private final double WHEEL_DIAMETER = 2.0;
    private final double WHEEL_GEAR_REDUCTION = 3.0;
    private final double MAX_RPM = 5700;

    private SparkMaxPIDController m_pidController;
    private RelativeEncoder m_encoder;
    private double targetRPM = 0.0;
    private double actualRPM = 0.0;
    private double closedLoopError = 0;

    /**
    *
    */
    public RearShooter() {
        canSparkMAXRearShooter = new CANSparkMax(14, MotorType.kBrushless);
        canSparkMAXRearShooter.setIdleMode(IdleMode.kCoast);
        canSparkMAXRearShooter.setInverted(true);
        
        m_encoder = canSparkMAXRearShooter.getEncoder();
        actualRPM = m_encoder.getVelocity();
        closedLoopError = actualRPM - targetRPM;

        // 03/08/2022 PID was tuned -- no ball!
        m_pidController = canSparkMAXRearShooter.getPIDController();
        m_pidController.setP(.0001);
        m_pidController.setI(0);
        m_pidController.setD(0);
        m_pidController.setIZone(0);
        m_pidController.setFF(0.00019);
        m_pidController.setOutputRange(-1, 1);
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        if (targetRPM != 0) {
            actualRPM = m_encoder.getVelocity();
            closedLoopError = actualRPM - targetRPM;
            SmartDashboard.putNumber("RearTarget", targetRPM);
            SmartDashboard.putNumber("RearActualPID", actualRPM);
            SmartDashboard.putNumber("RearError", closedLoopError);
            SmartDashboard.putBoolean("RearAtSetpoint", isFlywheelAtVelocity());
        }
        else {
            SmartDashboard.putNumber("RearTarget", 0);
            SmartDashboard.putNumber("RearActualPID", 0);
            SmartDashboard.putNumber("RearError", 0);
            SmartDashboard.putBoolean("RearAtSetpoint", false);
        }
        SmartDashboard.putNumber("RearVelocity", m_encoder.getVelocity());
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem here. Call these from Commands.
    /* -----------------------------------------------------------------------------------------------
     * Methods used in all modes (percent output, automatic PID, Dashboard PID)
     * -----------------------------------------------------------------------------------------------*/
    public void RearShooterStop(){
        canSparkMAXRearShooter.stopMotor();
        targetRPM = 0;
    }


    /* -----------------------------------------------------------------------------------------------
     * Methods for Percent Output TESTING ONLY
     * -----------------------------------------------------------------------------------------------*/
    public void RearShooterOut(){
        canSparkMAXRearShooter.set(REAR_POWER);
        }
    
    public void RearShooterIn(){
        canSparkMAXRearShooter.set(-REAR_POWER);
    }

    public void RearShooterOutPower (double power) {
      canSparkMAXRearShooter.set(power);
      SmartDashboard.putNumber("powerRear", power);
    }

    /* -----------------------------------------------------------------------------------------------
     * Methods for Automatic PID Closed Loop Control
     * -----------------------------------------------------------------------------------------------*/

    public void rearflywheelUpSpeed(Constants.ShootingConstants.ShootingPosition position) {
        Constants.ShootingConstants temp = new Constants.ShootingConstants();       // Currently in RPM
        targetRPM = 0;
        if (position == Constants.ShootingConstants.ShootingPosition.DISTANCE) {
            targetRPM = determinePowerFromDistance();
        }
        else {
            targetRPM = temp.getShootingSpeed(position, Constants.ShootingConstants.SubSystem.REARSHOOTER);
        }
        m_pidController.setReference(targetRPM, CANSparkMax.ControlType.kVelocity);
    }    
    
    // TODO: Implement Algorithm to find power based on distance
    public double determinePowerFromDistance(){
        Constants.ShootingConstants temp = new Constants.ShootingConstants();
        double calculatedPower = 0;
        double distance = RobotContainer.getInstance().getDistance();
        ShootingPosition calculatedPosition;
        calculatedPosition = temp.getPositionFromDistance(distance);
        calculatedPower = temp.getShootingSpeed(calculatedPosition, Constants.ShootingConstants.SubSystem.REARSHOOTER);
        return calculatedPower;
    }

    /* ORIGINAL
     * m_encoder.getVelocity is always ZERO and I don't know why
     * 
    public boolean isFlywheelAtVelocity(){
        double closedLoopError = m_encoder.getVelocity() - targetRPM;
        SmartDashboard.putNumber("RearShooterActualVelocity", m_encoder.getVelocity());
        SmartDashboard.putNumber("RearShooterTargetVelocity", targetRPM);
        SmartDashboard.putNumber("RearClosedLoopError", closedLoopError);
        if (Math.abs(closedLoopError) < 100 ) return true;
        else return false;
    }
    */

    /* Break Up the definition of closed loop error
     * A shot in the dark -- there is no reason this should make a difference
     */ 
    public boolean isFlywheelAtVelocity(){
        double error = 0;
        double actual = 0;
        actual = m_encoder.getVelocity();
        error = actual - targetRPM;
        SmartDashboard.putNumber("RearCheckActual", actual);
        SmartDashboard.putNumber("RearCheckTarget", targetRPM);
        SmartDashboard.putNumber("RearCheckError", error);
        if (Math.abs(error) < 100 ) return true;
        else return false;
    }
    

    /* Based on Periodic Method Updates 
    public boolean isFlywheelAtVelocity(){
        if (Math.abs(closedLoopError) < 100 ) return true;
        else return false;
    }
    */

    private double convertFPStoRPM (double fps){
        return (60 * 12 * fps) / (WHEEL_GEAR_REDUCTION * WHEEL_DIAMETER * Math.PI);
    }

    private double convertRPMtoFPS (double rpm){
        return (rpm * WHEEL_GEAR_REDUCTION * WHEEL_DIAMETER * Math.PI) / (60 *12);
    }

    /* -----------------------------------------------------------------------------------------------
     * Methods for DASHBOARD Control of PID Closed Loop Control
     * -----------------------------------------------------------------------------------------------*/
    public void incrementShooterVelocity() {
        CURRENT_SHOOTER_VELOCITY = CURRENT_SHOOTER_VELOCITY + 475;
        if (CURRENT_SHOOTER_VELOCITY > MAX_SHOOTER_VELOCITY) CURRENT_SHOOTER_VELOCITY = MAX_SHOOTER_VELOCITY;
        SmartDashboard.putNumber("RearRequestVelocity", CURRENT_SHOOTER_VELOCITY);
    }

    public void decrementShooterVelocity() {
        CURRENT_SHOOTER_VELOCITY = CURRENT_SHOOTER_VELOCITY - 475;
        if (CURRENT_SHOOTER_VELOCITY < 0) CURRENT_SHOOTER_VELOCITY = 0;
        SmartDashboard.putNumber("RearRequestVelocity", CURRENT_SHOOTER_VELOCITY);
    }

    public void testVelocity() {
        m_pidController.setReference(SmartDashboard.getNumber("RearRequestVelocity", CURRENT_SHOOTER_VELOCITY), CANSparkMax.ControlType.kVelocity);
    }
}

